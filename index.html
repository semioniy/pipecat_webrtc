<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Local WebRTC Voice Agent</title>
  <style>
    :root {
      --bg: #0b0f17;
      --panel: #111827;
      --panel2: #0f172a;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: rgba(255,255,255,0.08);
      --good: #10b981;
      --warn: #f59e0b;
      --bad:  #ef4444;
      --chip: rgba(255,255,255,0.06);
      --shadow: 0 10px 25px rgba(0,0,0,0.35);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 700px at 20% 0%, rgba(59,130,246,0.18), transparent 60%),
                  radial-gradient(900px 500px at 100% 30%, rgba(16,185,129,0.16), transparent 55%),
                  var(--bg);
      color: var(--text);
    }

    .wrap {
      max-width: 1150px;
      margin: 28px auto;
      padding: 0 16px 28px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      margin-bottom: 16px;
    }

    h1 {
      margin: 0 0 6px 0;
      font-size: 22px;
      letter-spacing: 0.2px;
    }
    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.3;
    }

    .grid {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
      align-items: start;
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card .hd {
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      background: rgba(255,255,255,0.02);
    }

    .card .hd h2 {
      margin: 0;
      font-size: 14px;
      font-weight: 650;
      color: #f3f4f6;
      letter-spacing: 0.2px;
    }

    .card .bd { padding: 14px; }

    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .col { display: flex; flex-direction: column; gap: 10px; }

    button {
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 650;
      transition: transform 0.04s ease, background 0.1s ease;
    }
    button:hover { background: rgba(255,255,255,0.09); }
    button:active { transform: translateY(1px); }
    button.primary {
      background: rgba(59,130,246,0.28);
      border-color: rgba(59,130,246,0.45);
    }
    button.primary:hover { background: rgba(59,130,246,0.35); }
    button.danger {
      background: rgba(239,68,68,0.22);
      border-color: rgba(239,68,68,0.40);
    }
    button.danger:hover { background: rgba(239,68,68,0.30); }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 7px 10px;
      border-radius: 999px;
      background: var(--chip);
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
      user-select: none;
    }

    .dot {
      width: 10px; height: 10px;
      border-radius: 50%;
      background: var(--muted);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.25) inset;
    }
    .dot.good { background: var(--good); }
    .dot.warn { background: var(--warn); }
    .dot.bad  { background: var(--bad); }
    .label-strong { color: #f3f4f6; }

    .kv {
      display: grid;
      grid-template-columns: 92px 1fr;
      gap: 10px;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
    }
    .kv .k { font-family: var(--mono); opacity: 0.85; }
    .kv .v { color: #d1d5db; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    .meter {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      overflow: hidden;
    }
    .meter > div {
      height: 100%;
      width: 0%;
      background: rgba(16,185,129,0.7);
      transition: width 0.05s linear;
    }

    .chat {
      height: 520px;
      overflow: auto;
      padding: 14px;
      background: rgba(0,0,0,0.18);
    }

    .msg {
      display: grid;
      grid-template-columns: 38px 1fr;
      gap: 10px;
      margin-bottom: 12px;
    }
    .avatar {
      width: 38px; height: 38px;
      border-radius: 12px;
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      display: grid;
      place-items: center;
      font-weight: 800;
      color: #e5e7eb;
      user-select: none;
    }
    .bubble {
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      line-height: 1.35;
      font-size: 13px;
      color: #e5e7eb;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .meta {
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
    }

    .msg.user .avatar { background: rgba(59,130,246,0.20); border-color: rgba(59,130,246,0.28); }
    .msg.user .bubble { background: rgba(59,130,246,0.10); border-color: rgba(59,130,246,0.20); }
    .msg.asst .avatar { background: rgba(16,185,129,0.18); border-color: rgba(16,185,129,0.26); }
    .msg.asst .bubble { background: rgba(16,185,129,0.08); border-color: rgba(16,185,129,0.18); }

    .log {
      font-family: var(--mono);
      font-size: 11px;
      color: #cbd5e1;
      background: rgba(0,0,0,0.25);
      border-top: 1px solid var(--border);
      padding: 10px 12px;
      max-height: 180px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .footerbar {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-top: 1px solid var(--border);
      background: rgba(255,255,255,0.02);
    }

    input[type="checkbox"] { transform: translateY(1px); }

    audio { width: 0; height: 0; opacity: 0; }
    .muted { color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Local WebRTC Voice Agent</h1>
        <p class="subtitle">
          Pipecat SmallWebRTCTransport · Ollama GPT-OSS · Faster-Whisper STT · Chatterbox TTS
        </p>
      </div>
      <div class="row">
        <span class="chip" title="WebRTC connection state">
          <span id="webrtc-dot" class="dot"></span>
          <span class="label-strong">WebRTC:</span>
          <span id="webrtc-state">Disconnected</span>
        </span>
        <span class="chip" title="Microphone status">
          <span id="mic-dot" class="dot"></span>
          <span class="label-strong">Mic:</span>
          <span id="mic-state">Idle</span>
        </span>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT -->
      <div class="col">
        <div class="card">
          <div class="hd">
            <h2>Connection</h2>
            <span class="chip" title="ICE / DTLS selected candidate info appears in console">
              <span class="dot" id="ice-dot"></span>
              <span id="ice-state">ICE: —</span>
            </span>
          </div>
          <div class="bd">
            <div class="row" style="margin-bottom:10px;">
              <button id="connect-toggle" class="primary">Connect</button>
            </div>

            <div class="row" style="justify-content: space-between; margin-bottom: 10px;">
              <span class="chip" title="Try to automatically reconnect when disconnected">
                <input id="auto-reconnect" type="checkbox"/>
                <label for="auto-reconnect">Auto-reconnect</label>
              </span>
              <span class="chip" title="When enabled, attempts to open a WebRTC data channel named 'events'">
                <input id="use-datachannel" type="checkbox" checked/>
                <label for="use-datachannel">DataChannel</label>
              </span>
            </div>

            <div class="kv" style="margin-top: 10px;">
              <div class="k">Offer</div><div class="v" id="offer-url">/api/offer</div>
              <div class="k">Audio out</div><div class="v muted">WebRTC remote track → &lt;audio autoplay&gt;</div>
            </div>

            <div style="margin-top: 14px;">
              <div class="row" style="justify-content: space-between;">
                <span class="muted" style="font-size: 12px;">Mic level</span>
                <span class="muted" style="font-size: 12px;" id="mic-level-text">0%</span>
              </div>
              <div class="meter"><div id="mic-meter"></div></div>
            </div>
          </div>
          <div class="log" id="log"></div>
        </div>

        <div class="card">
          <div class="hd">
            <h2>Services</h2>
            <span class="chip" title="Health checks run every few seconds">
              <span class="dot" id="health-dot"></span>
              <span id="health-state">Polling</span>
            </span>
          </div>
          <div class="bd">
            <div class="row" style="gap: 8px; flex-wrap: wrap;">
              <span class="chip" title="Ollama / OpenAI-compatible LLM base">
                <span id="llm-dot" class="dot"></span>
                <span class="label-strong">LLM</span>
                <span id="llm-status">Unknown</span>
              </span>
              <span class="chip" title="Faster-Whisper / OpenAI-compatible STT base">
                <span id="stt-dot" class="dot"></span>
                <span class="label-strong">STT</span>
                <span id="stt-status">Unknown</span>
              </span>
              <span class="chip" title="Chatterbox Turbo / OpenAI-compatible TTS base">
                <span id="tts-dot" class="dot"></span>
                <span class="label-strong">TTS</span>
                <span id="tts-status">Unknown</span>
              </span>
            </div>

            <div class="kv" style="margin-top: 14px;">
              <div class="k">LLM</div><div class="v" id="llm-url"></div>
              <div class="k">STT</div><div class="v" id="stt-url"></div>
              <div class="k">TTS</div><div class="v" id="tts-url"></div>
            </div>

            <p class="muted" style="margin: 12px 0 0; font-size: 12px; line-height: 1.35;">
              If these show <b>CORS</b> or <b>Blocked</b>, it’s the browser refusing cross-origin requests.
              In that case, expose a same-origin proxy endpoint (e.g. <span style="font-family:var(--mono)">/api/health/llm</span>)
              on your Pipecat server.
            </p>
          </div>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div class="hd">
          <h2>Transcript</h2>
          <div class="row">
            <button id="clear-chat">Clear</button>
            <span class="chip" title="Shows whether we are receiving transcript events from the server">
              <span id="events-dot" class="dot"></span>
              <span class="label-strong">Events</span>
              <span id="events-state">Idle</span>
            </span>
          </div>
        </div>

        <div class="chat" id="chat"></div>

        <div class="footerbar">
          <div class="muted" style="font-size: 12px;">
            Tip: have your server send JSON over DataChannel:
            <span style="font-family:var(--mono)">{"type":"user","text":"..."} </span>
            /
            <span style="font-family:var(--mono)">{"type":"assistant","text":"..."}</span>
          </div>
          <div class="muted" style="font-size: 12px;" id="last-event">—</div>
        </div>

        <audio id="audio-el" autoplay></audio>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // Config
    // =========================
    // Health is checked server-side to avoid browser CORS/network issues.
    const HEALTH_URL = "/api/health";
    let LLM_BASE = "";
    let STT_BASE = "";
    let TTS_BASE = "";
    const HEALTH_INTERVAL_MS = 4000;

    // Optional SSE endpoint if you add it later (disabled by default).
    const ENABLE_SSE = false;
    const SSE_URL = "/api/events";

    // =========================
    // Elements
    // =========================
    const status = {
      webrtcDot: el("webrtc-dot"),
      webrtcState: el("webrtc-state"),
      micDot: el("mic-dot"),
      micState: el("mic-state"),
      iceDot: el("ice-dot"),
      iceState: el("ice-state"),

      llmDot: el("llm-dot"),
      llmStatus: el("llm-status"),
      sttDot: el("stt-dot"),
      sttStatus: el("stt-status"),
      ttsDot: el("tts-dot"),
      ttsStatus: el("tts-status"),

      healthDot: el("health-dot"),
      healthState: el("health-state"),

      eventsDot: el("events-dot"),
      eventsState: el("events-state"),
      lastEvent: el("last-event"),
    };

    const connectToggleBtn = el("connect-toggle");
    const legacyConnectBtn = el("connect-btn");
    const legacyDisconnectBtn = el("disconnect-btn");
    const clearChatBtn = el("clear-chat");
    const autoReconnectEl = el("auto-reconnect");
    const useDataChannelEl = el("use-datachannel");

    const audioEl = el("audio-el");
    const chatEl = el("chat");
    const logEl = el("log");

    const micMeter = el("mic-meter");
    const micLevelText = el("mic-level-text");

    el("llm-url").textContent = "—";
    el("stt-url").textContent = "—";
    el("tts-url").textContent = "—";

    // =========================
    // State
    // =========================
    let connected = false;
    let peerConnection = null;
    let micStream = null;
    let micAnalyser = null;
    let micAudioCtx = null;
    let micRAF = null;

    let dataChannel = null;
    let sse = null;
    let lastTranscriptMessage = null;

    // =========================
    // Helpers
    // =========================
    function el(id) { return document.getElementById(id); }

    function log(...args) {
      const msg = args.map(a => typeof a === "string" ? a : JSON.stringify(a)).join(" ");
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      logEl.textContent += line;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(...args);
    }

    function setDot(dotEl, state) {
      dotEl.classList.remove("good","warn","bad");
      if (state) dotEl.classList.add(state);
    }

    function setStatusChip(dotEl, textEl, state, text) {
      setDot(dotEl, state);
      textEl.textContent = text;
    }

    function appendMessage(role, text) {
      const msg = document.createElement("div");
      msg.className = `msg ${role === "user" ? "user" : "asst"}`;

      const avatar = document.createElement("div");
      avatar.className = "avatar";
      avatar.textContent = role === "user" ? "U" : "A";

      const body = document.createElement("div");

      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.textContent = text;

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = `${role === "user" ? "User" : "Assistant"} · ${new Date().toLocaleTimeString()}`;

      body.appendChild(bubble);
      body.appendChild(meta);

      msg.appendChild(avatar);
      msg.appendChild(body);

      chatEl.appendChild(msg);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    // =========================
    // ICE helpers (kept from your version)
    // =========================
    const printSelectedIceCandidate = async (pc) => {
      try {
        const stats = await pc.getStats(null);
        stats.forEach(report => {
          if (report.type === "transport" && report.selectedCandidatePairId) {
            const candidatePair = stats.get(report.selectedCandidatePairId);
            const localCandidate = stats.get(candidatePair.localCandidateId);
            const remoteCandidate = stats.get(candidatePair.remoteCandidateId);
            console.log("Selected local candidate:", localCandidate);
            console.log("Selected remote candidate:", remoteCandidate);
          }
        });
      } catch (e) {
        log("ICE stats error:", String(e));
      }
    };

    const sendIceCandidate = async (pc, candidate) => {
      await fetch("/api/offer", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          pc_id: pc.pc_id,
          candidates: [{
            candidate: candidate.candidate,
            sdp_mid: candidate.sdpMid,
            sdp_mline_index: candidate.sdpMLineIndex
          }]
        })
      });
    };

    // =========================
    // Mic meter
    // =========================
    function startMicMeter(stream) {
      stopMicMeter();

      micAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = micAudioCtx.createMediaStreamSource(stream);
      micAnalyser = micAudioCtx.createAnalyser();
      micAnalyser.fftSize = 1024;
      source.connect(micAnalyser);

      const data = new Uint8Array(micAnalyser.fftSize);

      const tick = () => {
        micAnalyser.getByteTimeDomainData(data);
        // RMS level
        let sum = 0;
        for (let i = 0; i < data.length; i++) {
          const v = (data[i] - 128) / 128;
          sum += v * v;
        }
        const rms = Math.sqrt(sum / data.length);
        const pct = Math.min(100, Math.max(0, Math.round(rms * 140))); // tuned
        micMeter.style.width = pct + "%";
        micLevelText.textContent = pct + "%";
        micRAF = requestAnimationFrame(tick);
      };
      tick();
    }

    function stopMicMeter() {
      if (micRAF) cancelAnimationFrame(micRAF);
      micRAF = null;
      micMeter.style.width = "0%";
      micLevelText.textContent = "0%";

      try { micAnalyser?.disconnect?.(); } catch {}
      micAnalyser = null;

      if (micAudioCtx) {
        try { micAudioCtx.close(); } catch {}
        micAudioCtx = null;
      }
    }

    // =========================
    // Data channel / events
    // =========================
    function setupDataChannel(pc) {
      if (!useDataChannelEl.checked) return;

      // Create a channel that the server can also use to send transcript/events.
      // If server ignores it, this is harmless.
      dataChannel = pc.createDataChannel("events", { ordered: true });

      dataChannel.onopen = () => {
        setStatusChip(status.eventsDot, status.eventsState, "good", "DataChannel");
        log("DataChannel open");
        // Optional hello handshake
        safeSendEvent({ type: "hello", ts: Date.now() });
      };

      dataChannel.onclose = () => {
        setStatusChip(status.eventsDot, status.eventsState, "warn", "Closed");
        log("DataChannel closed");
      };

      dataChannel.onerror = (e) => {
        setStatusChip(status.eventsDot, status.eventsState, "bad", "Error");
        log("DataChannel error:", e?.message || String(e));
      };

      dataChannel.onmessage = (ev) => {
        status.lastEvent.textContent = new Date().toLocaleTimeString();
        try {
          const obj = JSON.parse(ev.data);
          handleServerEvent(obj);
        } catch {
          // allow plain text too
          handleServerEvent({ type: "log", text: String(ev.data) });
        }
      };
    }

    function safeSendEvent(obj) {
      try {
        if (dataChannel && dataChannel.readyState === "open") {
          dataChannel.send(JSON.stringify(obj));
        }
      } catch {}
    }

    function eventText(evt) {
      if (!evt) return "";
      if (typeof evt.text === "string" && evt.text.trim()) return evt.text.trim();
      if (evt.data && typeof evt.data.text === "string" && evt.data.text.trim()) return evt.data.text.trim();
      if (evt.data && typeof evt.data.content === "string" && evt.data.content.trim()) return evt.data.content.trim();
      if (typeof evt.content === "string" && evt.content.trim()) return evt.content.trim();
      return "";
    }

    function eventBool(evt, ...paths) {
      for (const path of paths) {
        let cur = evt;
        for (const key of path) {
          if (!cur || typeof cur !== "object" || !(key in cur)) {
            cur = undefined;
            break;
          }
          cur = cur[key];
        }
        if (typeof cur === "boolean") return cur;
      }
      return null;
    }

    function classifyTranscriptEvent(evt) {
      const type = String(evt?.type || "").toLowerCase();
      const label = String(evt?.label || evt?.data?.label || "").toLowerCase();
      const role = String(evt?.role || evt?.data?.role || evt?.speaker || "").toLowerCase();

      if (role === "user" || role === "assistant") return role;
      if (label === "assistant.tts_text") return "assistant";

      if (type === "assistant" || type === "assistant_text") return "assistant";
      if (type === "user" || type === "user_text") return "user";

      if (type.includes("llm") || type.includes("tts") || type.includes("metrics") || type.includes("started") || type.includes("stopped")) {
        return null;
      }

      if (type.includes("stt") || type.includes("transcription") || type.includes("transcript")) {
        const isPartial = type.includes("partial") || type.includes("interim");
        const isFinal = eventBool(evt, ["final"], ["is_final"], ["data", "final"], ["data", "is_final"]);
        if (isPartial || isFinal === false) return null;
        return "user";
      }

      return null;
    }

    function appendTranscriptEvent(evt) {
      const role = classifyTranscriptEvent(evt);
      const text = eventText(evt);
      if (!role || !text) return false;

      const fingerprint = `${role}:${text}`;
      if (lastTranscriptMessage === fingerprint) return true;

      appendMessage(role, text);
      lastTranscriptMessage = fingerprint;
      return true;
    }

    function handleServerEvent(evt) {
      // Expected examples:
      // {type:"user", text:"..."}  (final transcript)
      // {type:"user_partial", text:"..."} (optional)
      // {type:"assistant", text:"..."} (what you feed to TTS)
      // {type:"status", llm:"ok", stt:"ok", tts:"ok"} (optional)
      // {type:"log", text:"..."} (optional)
      if (!evt || !evt.type) return;

      if (appendTranscriptEvent(evt)) {
        return;
      }

      if (evt.type === "log" && evt.text) {
        log("server:", evt.text);
      } else if (evt.type === "status") {
        // Optional: server-driven status overrides
        if (evt.llm) applyServiceState("llm", evt.llm);
        if (evt.stt) applyServiceState("stt", evt.stt);
        if (evt.tts) applyServiceState("tts", evt.tts);
      } else {
        // Unknown event — still log it
        log("event:", evt);
      }
    }

    function startSSE() {
      if (!ENABLE_SSE) return;
      try {
        sse = new EventSource(SSE_URL);
        sse.onopen = () => {
          setStatusChip(status.eventsDot, status.eventsState, "good", "SSE");
          log("SSE open");
        };
        sse.onerror = () => {
          setStatusChip(status.eventsDot, status.eventsState, "warn", "SSE error");
        };
        sse.onmessage = (m) => {
          status.lastEvent.textContent = new Date().toLocaleTimeString();
          try { handleServerEvent(JSON.parse(m.data)); }
          catch { handleServerEvent({ type: "log", text: String(m.data) }); }
        };
      } catch (e) {
        log("SSE failed:", String(e));
      }
    }

    function stopSSE() {
      try { sse?.close?.(); } catch {}
      sse = null;
    }

    // =========================
    // WebRTC
    // =========================
    const addPeerConnectionEventListeners = (pc) => {
      pc.oniceconnectionstatechange = () => {
        log("iceConnectionState:", pc.iceConnectionState);
        const s = pc.iceConnectionState;
        if (s === "connected" || s === "completed") {
          setStatusChip(status.iceDot, status.iceState, "good", `ICE: ${s}`);
        } else if (s === "checking") {
          setStatusChip(status.iceDot, status.iceState, "warn", `ICE: ${s}`);
        } else if (s === "failed" || s === "disconnected" || s === "closed") {
          setStatusChip(status.iceDot, status.iceState, "bad", `ICE: ${s}`);
        } else {
          setStatusChip(status.iceDot, status.iceState, null, `ICE: ${s}`);
        }
      };

      pc.onconnectionstatechange = () => {
        log("connectionState:", pc.connectionState);
        const s = pc.connectionState;
        if (s === "connected") {
          onConnected();
        } else if (s === "disconnected" || s === "failed") {
          onDisconnected(true);
        } else if (s === "closed") {
          onDisconnected(false);
        } else if (s === "connecting") {
          onConnecting();
        }
      };

      pc.onicecandidate = async (event) => {
        if (event.candidate) {
          log("ICE candidate:", event.candidate.type || "candidate");
          if (pc.canSendIceCandidates && pc.pc_id) {
            await sendIceCandidate(pc, event.candidate);
          } else {
            pc.pendingIceCandidates.push(event.candidate);
          }
        } else {
          log("ICE gathering complete");
        }
      };
    };

    const createSmallWebRTCConnection = async (audioTrack) => {
      const config = {
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      };

      const pc = new RTCPeerConnection(config);

      pc.pendingIceCandidates = [];
      pc.canSendIceCandidates = false;

      addPeerConnectionEventListeners(pc);

      pc.ontrack = (e) => {
        log("Remote track received");
        audioEl.srcObject = e.streams[0];
      };

      if (useDataChannelEl.checked) {
        setupDataChannel(pc);
      } else {
        setStatusChip(status.eventsDot, status.eventsState, null, "Disabled");
      }

      // SmallWebRTCTransport expects both transceivers
      pc.addTransceiver(audioTrack, { direction: "sendrecv" });
      pc.addTransceiver("video", { direction: "sendrecv" });

      await pc.setLocalDescription(await pc.createOffer());
      const offer = pc.localDescription;

      const response = await fetch("/api/offer", {
        body: JSON.stringify({ sdp: offer.sdp, type: offer.type }),
        headers: { "Content-Type": "application/json" },
        method: "POST",
      });

      const answer = await response.json();
      pc.pc_id = answer.pc_id;

      await pc.setRemoteDescription(answer);

      pc.canSendIceCandidates = true;
      for (const candidate of pc.pendingIceCandidates) {
        await sendIceCandidate(pc, candidate);
      }
      pc.pendingIceCandidates = [];

      return pc;
    };

    async function connect() {
      onConnecting();
      try {
        status.micState.textContent = "Requesting…";
        setDot(status.micDot, "warn");

        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        status.micState.textContent = "On";
        setDot(status.micDot, "good");

        startMicMeter(micStream);

        peerConnection = await createSmallWebRTCConnection(micStream.getAudioTracks()[0]);
        startSSE();

      } catch (e) {
        log("Connect failed:", String(e));
        onDisconnected(false);
        throw e;
      }
    }

    function disconnect() {
      log("Disconnecting…");

      stopSSE();

      if (dataChannel) {
        try { dataChannel.close(); } catch {}
      }
      dataChannel = null;

      if (peerConnection) {
        try { peerConnection.close(); } catch {}
      }
      peerConnection = null;

      if (micStream) {
        try { micStream.getTracks().forEach(t => t.stop()); } catch {}
      }
      micStream = null;

      stopMicMeter();

      status.micState.textContent = "Idle";
      setDot(status.micDot, null);

      onDisconnected(false);
    }

    function getConnectControl() {
      return connectToggleBtn || legacyConnectBtn;
    }

    function refreshConnectButton() {
      const btn = getConnectControl();
      if (!btn) return;

      // If older markup is present, hide old dedicated disconnect control.
      if (legacyDisconnectBtn) legacyDisconnectBtn.style.display = "none";

      if (connected) {
        btn.textContent = "Disconnect";
        btn.classList.remove("primary");
        btn.classList.add("danger");
      } else {
        btn.textContent = "Connect";
        btn.classList.remove("danger");
        btn.classList.add("primary");
      }
    }

    function onConnecting() {
      setStatusChip(status.webrtcDot, status.webrtcState, "warn", "Connecting");
      connected = true;
      refreshConnectButton();
    }

    function onConnected() {
      printSelectedIceCandidate(peerConnection);
      setStatusChip(status.webrtcDot, status.webrtcState, "good", "Connected");
      connected = true;
      refreshConnectButton();

      // Mark events as waiting if enabled but not open yet
      if (useDataChannelEl.checked && (!dataChannel || dataChannel.readyState !== "open")) {
        setStatusChip(status.eventsDot, status.eventsState, "warn", "Waiting…");
      }
    }

    function onDisconnected(maybeReconnect) {
      setStatusChip(status.webrtcDot, status.webrtcState, "bad", "Disconnected");
      connected = false;
      refreshConnectButton();

      if (maybeReconnect && autoReconnectEl.checked) {
        log("Auto-reconnect scheduled…");
        setTimeout(async () => {
          if (connected) return;
          try { await connect(); }
          catch (e) { log("Auto-reconnect failed:", String(e)); }
        }, 1200);
      }
    }

    // =========================
    // Health polling
    // =========================
    function applyServiceState(which, state) {
      // state: "ok" | "warn" | "bad" | "unknown" | any string
      const map = {
        ok:   { dot: "good", text: "OK" },
        warn: { dot: "warn", text: "Degraded" },
        bad:  { dot: "bad",  text: "Down" },
        unknown: { dot: null, text: "Unknown" }
      };
      const m = map[state] || null;

      if (which === "llm") {
        setStatusChip(status.llmDot, status.llmStatus, m ? m.dot : null, m ? m.text : String(state));
      } else if (which === "stt") {
        setStatusChip(status.sttDot, status.sttStatus, m ? m.dot : null, m ? m.text : String(state));
      } else if (which === "tts") {
        setStatusChip(status.ttsDot, status.ttsStatus, m ? m.dot : null, m ? m.text : String(state));
      }
    }

    async function pollHealth() {
      setStatusChip(status.healthDot, status.healthState, "warn", "Polling…");
      try {
        const res = await fetch(HEALTH_URL, { method: "GET" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const payload = await res.json();

        LLM_BASE = payload?.services?.llm || LLM_BASE;
        STT_BASE = payload?.services?.stt || STT_BASE;
        TTS_BASE = payload?.services?.tts || TTS_BASE;
        el("llm-url").textContent = LLM_BASE || "—";
        el("stt-url").textContent = STT_BASE || "—";
        el("tts-url").textContent = TTS_BASE || "—";

        const h = payload?.health || {};
        applyServiceState("llm", h.llm || "unknown");
        applyServiceState("stt", h.stt || "unknown");
        applyServiceState("tts", h.tts || "unknown");

        const anyBad = [h.llm, h.stt, h.tts].includes("down");
        const allGood = [h.llm, h.stt, h.tts].every(v => v === "ok");

        if (allGood) setStatusChip(status.healthDot, status.healthState, "good", "Healthy");
        else if (anyBad) setStatusChip(status.healthDot, status.healthState, "bad", "Issues");
        else setStatusChip(status.healthDot, status.healthState, "warn", "Partial");
      } catch (e) {
        setStatusChip(status.healthDot, status.healthState, "bad", "Unavailable");
        applyServiceState("llm", "unknown");
        applyServiceState("stt", "unknown");
        applyServiceState("tts", "unknown");
        log("Health request failed:", String(e));
      }
    }

    // =========================
    // UI wiring
    // =========================
    getConnectControl()?.addEventListener("click", async () => {
      if (connected) {
        disconnect();
        return;
      }
      try { await connect(); }
      catch {}
    });
    legacyDisconnectBtn?.addEventListener("click", () => disconnect());
    clearChatBtn.addEventListener("click", () => {
      chatEl.innerHTML = "";
      lastTranscriptMessage = null;
      status.lastEvent.textContent = "—";
    });

    // Initial state
    setStatusChip(status.webrtcDot, status.webrtcState, null, "Disconnected");
    refreshConnectButton();
    setStatusChip(status.iceDot, status.iceState, null, "ICE: —");
    setStatusChip(status.eventsDot, status.eventsState, null, "Idle");
    applyServiceState("llm", "unknown");
    applyServiceState("stt", "unknown");
    applyServiceState("tts", "unknown");

    // Health loop
    pollHealth();
    setInterval(pollHealth, HEALTH_INTERVAL_MS);
  </script>
</body>
</html>
